{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/12/24/hello-world/"},{"title":"안녕하세요hexo","text":"테스트 제목안녕하세요 hexo 새글을 쓴다 터미널에서 “hexo generate” 터미널에서 “hexo deploy” 블로그를 확인한다!","link":"/2019/12/24/%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94hexo/"},{"title":"주사위굴리기_14499번","text":"14499번 문제 풀이 주사위가 좌표면을 움직일때마다 윗면에 쓰여있는 숫자를 출력하는 문제이다. 1.규칙에 따라 주사위와 좌표면의 숫자들이 바뀌므로 바뀌는 주사위 면의 숫자들을 저장하고자 했다. &nbsp;&nbsp;&nbsp;따라서, 아래와 같이 dice라는 리스트를 주사위값 저장에 사용했다. 1dice = [0,0,0,0,0,0] #위0 아래1 동2 서3 남4 북5 순서로 값 2.주사위가 움직이는 지도가 어떻게 생겼는지를 알아야했다. &nbsp;&nbsp;&nbsp;따라서, 아래와 같이 입력받은 크기에 맞는 지도를 생성했다. 12345field = []for row in range(rows): li = list(map(int, input().split())) field.append(li) 3.주어지는 움직임대로 주사위를 움직이고 그에따라 지도의 값과 dice의 값을 바꿔주어야한다. 123456789101112131415161718192021for i in range(len(moves)): temp = 0 if moves[i] == 1: if position_y + 1 &lt; columns: position_y += 1 temp = dice[2] field_num = field[position_x][position_y] if field_num == 0: dice[2] = dice[0] dice[0] = dice[3] dice[3] = dice[1] dice[1] = temp field[position_x][position_y] = temp else: dice[2] = dice[0] dice[0] = dice[3] dice[3] = dice[1] dice[1] = field[position_x][position_y] field[position_x][position_y] = 0 else : continue 주사위가 특정 방향으로 움직이기전에, temp값에 바닥을 향할 주사위 값을 미리 저장해주었다. 그리고 주사위가 움직일때, 현재 좌표값들을 변경시켜준다. 이때 주의할점은 우리는 문제에서 값을 입력받을때 세로크기를 먼저받고 그 다음으로 가로 크기를 받는다는 점이다. 즉 동쪽으로 움직이면 y좌표가 늘어난다. 주사위가 굴렀다면, dice 리스트에 값들을 바꿔줘야한다. 위와같이 동쪽으로 굴렀다면, 위를 바라보던 주사위 면은 동쪽을 바라보게 될테고 서쪽을 바라보던 주사위면은 위를 바라보게 될 것이다. 이와 같이 주사위 면의 값들을 dice에 바꿔서 입력한다. 이 과정을 동,서,남,북에 나눠서 처리하고 그때마다 주사위 윗면의 값을 프린트해주면 된다. Full CodeFull Code","link":"/2019/12/27/%EC%A3%BC%EC%82%AC%EC%9C%84%EA%B5%B4%EB%A6%AC%EA%B8%B0-14499%EB%B2%88/"},{"title":"Centauri","text":"[Python] 백준1011번 풀이Fly me to the Alpha Centauri1.거리에 따른 이동 규칙을 찾는 문제였다. 마지막 거리1을 제외한 나머지 거리를 역으로 탐색하는 방법을 생각했지만 규칙성을 찾아서 해결하는 문제에 옳지 못한 방법이었다.&nbsp;&nbsp;&nbsp;타 게시판에서 힌트를 찾을 수 있었는데, 일정 거리를 지속적으로 늘려가다가 결국 마지막 1광년을 가기 위해 어느 시점부터 다시 지속적으로 움직이는 거리를 줄여야 한다는것이다. 2.그렇다면 어느 시점부터 다시 움직이는 거리를 줄이는 것일까?&nbsp;&nbsp;&nbsp;이에 대한 해답은 총 이동거리에 따라서 어떻게 움직여야하는지 표를 그려 파악할 수 있었다. 거리 이동경로 움직인 횟수 1 1 1 2 1 1 2 3 1 1 1 3 4 1 2 1 3 5 1 2 1 1 4 6 1 2 2 1 4 7 1 2 2 1 1 5 8 1 2 2 2 1 5 9 1 2 3 2 1 5 10 1 2 3 2 1 1 6 11 1 2 3 2 2 1 6 12 1 2 3 3 2 1 6 13 1 2 3 3 2 1 1 7 14 1 2 3 3 2 2 1 7 15 1 2 3 3 3 2 1 7 16 1 2 3 4 3 2 1 7 17 1 2 3 4 3 2 1 1 8 18 1 2 3 4 3 2 2 1 8 19 1 2 3 4 3 3 2 1 8 20 1 2 3 4 3 3 2 1 8 21 1 2 3 4 4 3 2 1 1 9 3.위의 표를 살펴보면 제곱수가 되는 K(볼드체가 표시되어 있는 2,3,4….) 를 기준으로 움직인 회수가 바뀌는것을 확인할 수 있다.&nbsp;&nbsp;&nbsp;다시말해, 우리가 움직여야하는 거리가 주어졌을 때 가장 가까운 제곱수로 나타낼 수 있는 값 K를 찾아야한다. 12345x, y = map(int, input().split())stand = 0if math.sqrt(y-x) - math.floor(math.sqrt(y-x)) &lt; 0.5: stand = math.floor(math.sqrt(y-x))else: stand = math.ceil(math.sqrt(y-x)) 총 움직여야하는 거리 y-x 에 대해&nbsp;&nbsp;&nbsp;sqrt값과 sqrt의 floor값 차이를 구해 이 값이 0.5 보다 작다면 기준이 되는 K값(위의 코드에서는 stand값)은 sqrt의 floor값이라고 할 수 있다.반대로, 0.5보다 크다면 K값은 sqrt의 ceil값이 될 것이다. 4.기준이 되는 값 K를 구했다면 K와 움직인 횟수와의 관계를 살펴봐야 한다.&nbsp;&nbsp;&nbsp;우리가 움직인 거리와 K의 제곱값을 비교하면 알 수 있다.&nbsp;&nbsp;&nbsp;만약, y-x가 K의 제곱보다 크다면 움직인 횟수는 K2이며&nbsp;&nbsp;&nbsp;y-x가 k의 제곱보다 작거나 같다면 움직인 횟수는 k2-1의 규칙을 따르는 것을 확인할 수 있다. 1234if y-x &gt; stand**2: print(stand*2)elif y-x &lt;= stand**2: print(stand*2-1) Full codeFull code","link":"/2019/12/30/Fly%20me%20to%20the%20Alpha%20Centauri/"},{"title":"부녀회장이될테야_2775번","text":"[Python] 백준 2775번 풀이부녀회장이 될테야1.처음 문제를 일고 떠오른것은 점화식 문제였다.&nbsp;&nbsp;&nbsp;점화식을 만들기 위해 몇층을 예로들어 직접 작성해보았다. 0층 : 1 2 3 4 5 6 7 8…1층 : 1 3 6 10 15 21 28…2층 : 1 4 10 20 25 56…3층 : 1 5 15 35 70…4층 : 1 6 21 56 몇개의 예를 들어 적어놓고 보니 계차수열의 형태를 나타낸다고 생각했다.하지만 층수가 높아질수록 계차수열에 계차수열이 더해지는 형태로 나타났고 이를 점화식으로 나타내는것은 무리가 따랐다.따라서, 문제에서 요구하는 층수와 호실수가 많지 않았으므로 전체에 대한 계산 결과를 저장하기로 결정했다. 123456789li = [[0]*14 for i in range(15)]for i in range(1,15): li[0][i-1] = i li[i][0] = 1for i in range(1,15): for j in range(1,14): li[i][j] = li[i-1][j] + li[i][j-1] 0층을 포함한 총 15층의 데이터를 저장하고 테스트 케이스로 입력받은 내용을 나타내는것으로 마무리했다. Full CodeFull Code","link":"/2020/01/01/%EB%B6%80%EB%85%80%ED%9A%8C%EC%9E%A5%EC%9D%B4%EB%90%A0%ED%85%8C%EC%95%BC-2775%EB%B2%88/"},{"title":"hexo블로그_댓글창만들기_icarus테마","text":"icarus테마 hexo블로그에 disqus 댓글창을 만들어보자icarus테마 블로그에 disqus댓글창을 만들고자 5시간의 삽질을 기록하는 이야기이다.1.disqus사이트에 접속해 아이디를 만들어아합니다. 2.홈 화면에서 get started를 누른다. 3.”I want to install Disqus on My site”를 누릅니다. 4.website이름을 만들고자하는 이름으로 입력하고 카테고리 언어를 설정한 후 create site를 클릭합니다. 5.여러 유료모델이 있지만 트래픽이 높지 않은 개인 블로그이므로(높을수도 있지만?!) Basic 모델아래에 Subscribe Now를 눌러줍니다. 6.어떤 플랫폼을 사용하는지 물어보지만 우리는 github.io를 사용하기때문에 제일 아래쪽의 I dont’ see my platform listed….을 눌러줍니다. 7.Universal Code install instructions창이 뜹니다. 8.해당 창에서 제일 위의 settings을 눌러줍니다. 9.새로 열리는 창의 두번째칸에 Shortname이 있습니다. Your website shortname is XXXXX라고 나옵니다. shortname을 기억하시면됩니다. 이제 github.io블로그를 꾸미는 터미널로 들어갑니다!테마마다 설정하는 법이 모두 다르기때문에 icarus테마를 기준으로 설명하겠습니다.icarus테마의 icarus테마 댓글창 설정법에 들어가면 _config파일만 수정해 적용하도록 나와있습니다. 1234comment: # Name of the comment plugin type: disqus shortname: &lt;9번에서 기억한 shortname&gt; 위와 같이 _config파일을 수정하고 적용을 시키고 테스트를 하기위해 서버를 실행시켰지만 터미널에서는 comment.shortname을 찾을 수 없다는 에러메시지였습니다.여기서부터 장장 5시간의 삽질이 시작됐습니다.저의 에디터에서는 저렇게 수정한것처럼 보였습니다…하지만 다른 커뮤니티에 문의하기 위해 comment 아래 부분을 복사해서 메모장에 붙여넣기 해보니 실제로 입력되어있던 내용은 1234comment: # Name of the comment plugin type: disqus shortname: &lt;shortname&gt; 였습니다. OMG…comment.shortname을 찾을 수 없다는 에러메시지가 나오는게 당연한 상황이었습니다저걸 찾기까지 무려 5시간이 걸리다니… 에디터에서는 바르게 “보이길래” 의심도 못했습니다.(역시 갓모장…)결국 footer수정… disqus.ejs파일 수정…등등 삽질을 끝낼 수 있었습니다. 저와같은 오류가 뜬다면 삽질을 막기위해 _config 문서를 수정하시고 메모장에 복사 붙여넣기를 해보세요!결론적으로 _config.yml 파일의 comment 내용을 다음과 같이 수정하시면 올바르게 적용됩니다! 1234comment: # Name of the comment plugin type: disqus shortname: &lt;9번에서 기억한 shortname&gt; disqus파일은 수정하지 않으셔도되고 위와같이 수정한 후 1hexo server -p &lt;포트번호&gt; ## 로컬에서 확인하기 로컬에서 확인한 후 12hexo generatehexo deploy 로 배포하시면 됩니다.","link":"/2020/01/03/hexo%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%8C%93%EA%B8%80%EC%B0%BD%EB%A7%8C%EB%93%A4%EA%B8%B0-icarus%ED%85%8C%EB%A7%88/"},{"title":"택시기하학_3053번","text":"[Python] 백준 3053번 풀이택시 기하학1.택시 기하학에서 원이 어떻게 정의되는지 이해하면 매우 간단한 문제이다.&nbsp;&nbsp;&nbsp; 아래의 그림을 통해 택시 기하학에서의 원을 살펴볼 수 있다. 직교 좌표계에서 같은 거리에 있는 점들의 집합을 원이라고 정의하므로 위와같이 나타낼 수 있다. 따라서 빨간 점들을 살펴보면 정사각형을 이루는것을 알 수 있고 정사각형의 넓이는 반지름 r이 주어졌을때 다음과 같이 구할 수 있다. 1k = 2*(r**2) ## 피타고라스 정리에 의해 c^2 = a^2 + b^2 = a^2 + a^2 = 2*a^2 Full CodeFull Code","link":"/2020/01/03/%ED%83%9D%EC%8B%9C%EA%B8%B0%ED%95%98%ED%95%99-3053%EB%B2%88/"},{"title":"블랙잭_2798번","text":"[Python] 백준 2798번 풀이블랙잭1.모든 조합의 경우의 수를 따지는 문제이다.파이썬에서는 itertools의 combinations를 이용해 조합을 따질 수 있다. itertools.combinations에서 확인할 수 있다. 2.combinations는 combinations object를 리턴하는데 이를 for루프에 돌려 하나의 조합을 확인하게되면 튜플 을 리턴한다.예를들어, 1234li = [3,4,5]for i in itertools.combinations(li,2): print(i)## &gt;&gt; (3,4) , (3,5) , (4,5) 를 출력한다. 3.따라서 입력받은 N개의 숫자 리스트로부터 모든 조합을 따지면서 그 값이 상한값을 넘지않는 경우 새로운 변수에 입력해주면 된다. 1234567com_li = 0for i in itertools.combinations(li,3): s = sum(i) if s &gt; com_li and s &lt;= m: com_li = s else: pass Full CodeFull Code","link":"/2020/01/03/%EB%B8%94%EB%9E%99%EC%9E%AD-2798%EB%B2%88/"},{"title":"Golang_정리하기-1","text":"[Go tutorial] Go 정리하기 - 1Go-tour 참조 익스포트 Go 에서는 첫 문자가 대문자로 시작하면 특정 패키지를 사용하는 곳에서 접근할 수 있는 exported name이 됨 함수 Go 는 코드를 왼쪽부터 자연스럽게 읽기 위해 매개변수 타입은 변수명 뒤에 명시. 두 개 이상의 매개변수가 같은 타입일 때, 같은 타입을 취하는 마지막 매개변수에만 타입을 지정할 수 있음. 12345x int, y int#를 아래와 같이도 사용 가능x, y int 하나의 함수는 여러 개의 결과를 반환할 수 있음. 123func swap(x, y string) (string, string) { return y, x} 변수 var 을 통해 변수를 선언. 변수 선언과 함꼐 초기화 가능, 초기화를 하는 경우 타입 생략 가능. 이 경우, 초기화하고자 하는 값에 따라 타입이 결정됨. 1var a, b, c int = 1, 2, 3 함수 내에서 := 을 사용하면 var와 명시적인 타입을 생략할 수 있음. 상수 const 키워드와 함께 변수처럼 선언. 상수는 문자, 문자열, boolean, 숫자 타입 중의 하나가 될 수 있음 숫자형 상수는 정밀한 값을 표현할 수 있음. Go-tour 사이트에서 제공하는 예제를 이해하기 위해서는 Go의 &lt;&lt; 와 &gt;&gt; 연산자의 이해가 필요하다. &lt;&lt;, &gt;&gt; 연산자에 대해 &lt;&lt; 와 &gt;&gt; 연산자는 비트 이동 연산자로 Left shift, Right shift 라고 함. Left shift 는 현재 값의 비트를 주어진 값만큼 왼쪽으로 Right shift는 현재 값의 비트를 주어진 값만큼 오른쪽으로 옮깁니다.1234567891011const (a = 1b = a &lt;&lt; 1)func main() { fmt.Println(a) ### 1 출력 fmt.Printf(\"%08b\\n\", a) ### 00000001 출력 fmt.Println(b) ### 2 출력 fmt.Printf(\"%08b\", b) ### 00000010 출력} 반복문 for Go 에는 반복문으로 for 하나만 존재. 조건문만 표현해서 루프를 표현 가능. 1234567func main() { sum := 1 for sum &lt; 1000 { sum += sum } fmt.Println(sum)} 위와 같이 표현하면 while을 사용하듯 for을 사용할 수 있다. 조건문을 생략하는것으로 무한 루프를 만들 수 있다. 1234func main() { for { }} 조건문 if 반복문과 마찬가지로 실행문을 위한 { } 만 필요. for 처럼 조건문 앞에 문장을 실행할 수 있음. 123456func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v &lt; lim { return v } return lim} 위의 예를 보면, v &lt; lim 을 통한 조건문 앞에 v := math.Pow(x,n) 을 실행했다. 이렇게 선언된 변수(위에서는 v)는 if 안쪽 범위에서만(else 블럭 안에서도 가능) 사용할 수 있다. 연습 : 루프와 함수 &gt;&gt;&gt; solution","link":"/2020/01/06/Golang-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-1/"},{"title":"Golang_정리하기_2","text":"[Go tutorial] Go 정리하기 - 2Go-tour 참조구름edu 참조 구조체(Structs) structs는 데이터들의 조합 type선언으로 이름을 지정할 수 있음 “객체이름 := 구조체이름{저장할값}”으로 입력해 선언과 동시에 초기화할 수 있다. 구조체에 속한 필드(데이터)는 dot(.)으로 접근 1234567891011121314151617181920212223242526type person struct { name string age int contact string}func main() { var p1 = person{} fmt.Println(p1) p1.name = \"kim\" p1.age = 25 p1.contact = \"01000000000\" fmt.Println(p1) p2 := person{\"nam\", 31, \"01022220000\"} // 필드 이름을 생력할 시 순서대로 저장함 fmt.Println(p2) p3 := person{contact: \"01011110000\", name: \"park\", age: 23} // 필드 이름을 명시할 시 순서와 상관 없이 저장할 수 있음 fmt.Println(p3) p3.name = \"ryu\" //필드에 저장된 값을 수정할 수 있음 fmt.Println(p3) fmt.Println(p3.contact) //필드 값의 개별 접근도 가능함} 포인터 포인터 연산은 불가능 포인터를 이용한 간접 접근은 실제 구조체에도 영향을 끼침 “&amp;” 을 매개변수 앞에 붙여 pass by reference 를 통해 값이 저장된 주소에 직접 접근할 수 있음. 구조체 포인터를 생성하는 방법은 두 가지가 있다. ‘new(구조체이름)’ 을 사용하여 객체를 생성 구조체 이름 앞에 &amp; 붙이기 12345678910111213141516171819type Person struct { Name string}func main() { c := new(Person) // returns pointer c.Name = \"Catherine\" fmt.Println(c.Name) // prints: Catherine d := *c d.Name = \"Daniel\" fmt.Println(d.Name) // prints: Daniel i := &amp;d i.Name = \"Ines\" fmt.Println(c.Name) // prints: Catherine fmt.Println(d.Name) // prints: Ines fmt.Println(i.Name) // prints: Ines} 슬라이스(slice) 슬라이스는 참조 타입이다. 따라서, 슬라이스를 복사한다는 것은 같은 주소를 참조한다는 것이다. 복사한 슬라이스의 값을 바꾸면 참조하는 슬라이스의 해당 값도 바뀌게 된다. 슬라이스 선언 var a []int = []int{1,2,3,4} 와 같이 선언과 함께 초기화 make() 함수를 이용. make(슬라이스 타입, 슬라이스 길이, 슬라이스 용량) ex) s:=make([]int,3,3) append() 함수를 통해 슬라이스에 데이터를 추가할 수 있다. 슬라이스에 슬라이스를 추가하기 위해서는 슬라이스 뒤에 “…”을 입력 12345678910func main() { sliceA := []int{1, 2, 3} sliceB := []int{4, 5, 6} sliceA = append(sliceA, sliceB...) //sliceA = append(sliceA, 4, 5, 6) fmt.Println(sliceA) fmt.Println(sliceB)} copy(붙여넣을 슬라이스, 복사할 슬라이스) 를 통해 한 슬라이스를 다른 슬라이스로 복사할 수 있다. 12345678910111213141516func main() { c := make([]int, 0, 3) //용량이 3이고 길이가0인 정수형 슬라이스 선언 c = append(c, 1, 2, 3, 4, 5, 6, 7) fmt.Println(len(c), cap(c)) l := c[1:3] //인덱스 1요소부터 2요소까지 복사 fmt.Println(l) l = c[2:] //인덱스 2요소부터 끝까지 복사 fmt.Println(l) l[0] = 6 fmt.Println(c) //슬라이스 l의 값을 바꿨는데 c의 값도 바뀜//값을 복사해온 것이 아니라 기존 슬라이스 주솟값을 참조} 위의 예제를 실행해보면 slice c의 값도 l 에 의해 바뀌는것을 확인할 수 있다. 왜냐하면, 슬라이스는 배열과 다르게 슬라이스 자체가 참조하고 있는 주소값을 같이 참조하기 때문이다. 슬라이스 순회(iterates) 슬라이스는 for 반복문에서 range를 통해 순회할 수 있다. 이때, index와 value를 순회하며 필요치 않은 값은 “_” 를 이용해 무시할 수 있다. 연습 : 슬라이스 - 문제 연습 : 슬라이스 - solution","link":"/2020/01/07/Golang-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-2/"},{"title":"Golang_정리하기_3","text":"[Go tutorial] Go 정리하기 - 3Go-tour 참조구름edu 참조 맵(map) 키와 value의 조합을 나타내기 위한것으로 파이썬의 딕셔너리를 생각하자. var 맵이름 map[key자료형]value자료형 으로 선언 var a map[int]string :: key가 int이고 value가 string인 맵 a 선언만 하고 초기화하지 않는다면 Nil map 이다. 데이터 추가 or 갱신 :: 맵이름[key] = value 를 이용 데이터 삭제 :: delete(맵이름,key) 를 이용 123456789101112131415161718192021func main() { //지역번호와 지역 저장 var m = make(map[string]string) m[\"02\"] = \"서울특별시\" m[\"031\"] = \"경기도\" m[\"032\"] = \"충청남도\" m[\"053\"] = \"대구광역시\" fmt.Println(m) //동일한 key값으로 value값을 저장하면 갱신이 된다 m[\"032\"] = \"인천\" fmt.Println(m) //m에 있는 \"031\"key의 value와 함께 삭제 delete(m, \"031\") fmt.Println(m)} key체크, value 확인 “맵이름[key]” 는 value와 키가 존재하는지 여부를 반환한다. 존재하지 않는 키값이라면 자료형에따라 0 혹은 “” 를 반환 해당 키가 존재하는지 여부에 따라 true/false 반환 12345678910111213141516func main() { m := make(map[string]int) m[\"Answer\"] = 42 fmt.Println(\"The value:\", m[\"Answer\"]) ## print : The value: 42 m[\"Answer\"] = 48 fmt.Println(\"The value:\", m[\"Answer\"]) ## print : The value: 48 delete(m, \"Answer\") fmt.Println(\"The value:\", m[\"Answer\"]) ## print : The value: 0 v, ok := m[\"Answer\"] fmt.Println(\"The value:\", v, \"Present?\", ok) ## print : The value: 0 Present? false} 연습 : 맵 - 문제 연습 : 맵 - solution 함수 클로져 클로져는 함수 안에서 익명 함수를 정의해 바깥쪽 함수에서 선언한 변수에도 접근할 수 있는 함수를 뜻한다. 1234567891011121314151617func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum }}func main() { pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ { fmt.Println( pos(i), neg(-2*i), ) }} 위의 예에서 adder() 함수는 지역 변수 sum 을 초기화하고 입력받는 x를 더해주는 익명 함수를 반환합니다. for문에서 함수가 실행될때마다 지역 변수가 초기화되지않고 더해주는 익명함수만을 통해 값이 지속적으로 증가/감소 하는것을 확인할 수 있습니다. 연습 : 피보나치 클로져 - 문제 연습 : 피보나치 클로져 - solution","link":"/2020/01/08/Golang-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-3/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"baekjoon","slug":"baekjoon","link":"/tags/baekjoon/"},{"name":"github.io","slug":"github-io","link":"/tags/github-io/"},{"name":"블로그","slug":"블로그","link":"/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"Go","slug":"Go","link":"/tags/Go/"}],"categories":[{"name":"baekjoon","slug":"baekjoon","link":"/categories/baekjoon/"},{"name":"python","slug":"baekjoon/python","link":"/categories/baekjoon/python/"},{"name":"github.io","slug":"github-io","link":"/categories/github-io/"},{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"tutorial","slug":"Go/tutorial","link":"/categories/Go/tutorial/"}]}