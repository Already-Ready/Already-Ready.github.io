{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/12/24/hello-world/"},{"title":"안녕하세요hexo","text":"테스트 제목안녕하세요 hexo 새글을 쓴다 터미널에서 “hexo generate” 터미널에서 “hexo deploy” 블로그를 확인한다!","link":"/2019/12/24/%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94hexo/"},{"title":"주사위굴리기_14499번","text":"14499번 문제 풀이 주사위가 좌표면을 움직일때마다 윗면에 쓰여있는 숫자를 출력하는 문제이다. 1.규칙에 따라 주사위와 좌표면의 숫자들이 바뀌므로 바뀌는 주사위 면의 숫자들을 저장하고자 했다. &nbsp;&nbsp;&nbsp;따라서, 아래와 같이 dice라는 리스트를 주사위값 저장에 사용했다. 1dice = [0,0,0,0,0,0] #위0 아래1 동2 서3 남4 북5 순서로 값 2.주사위가 움직이는 지도가 어떻게 생겼는지를 알아야했다. &nbsp;&nbsp;&nbsp;따라서, 아래와 같이 입력받은 크기에 맞는 지도를 생성했다. 12345field = []for row in range(rows): li = list(map(int, input().split())) field.append(li) 3.주어지는 움직임대로 주사위를 움직이고 그에따라 지도의 값과 dice의 값을 바꿔주어야한다. 123456789101112131415161718192021for i in range(len(moves)): temp = 0 if moves[i] == 1: if position_y + 1 &lt; columns: position_y += 1 temp = dice[2] field_num = field[position_x][position_y] if field_num == 0: dice[2] = dice[0] dice[0] = dice[3] dice[3] = dice[1] dice[1] = temp field[position_x][position_y] = temp else: dice[2] = dice[0] dice[0] = dice[3] dice[3] = dice[1] dice[1] = field[position_x][position_y] field[position_x][position_y] = 0 else : continue 주사위가 특정 방향으로 움직이기전에, temp값에 바닥을 향할 주사위 값을 미리 저장해주었다. 그리고 주사위가 움직일때, 현재 좌표값들을 변경시켜준다. 이때 주의할점은 우리는 문제에서 값을 입력받을때 세로크기를 먼저받고 그 다음으로 가로 크기를 받는다는 점이다. 즉 동쪽으로 움직이면 y좌표가 늘어난다. 주사위가 굴렀다면, dice 리스트에 값들을 바꿔줘야한다. 위와같이 동쪽으로 굴렀다면, 위를 바라보던 주사위 면은 동쪽을 바라보게 될테고 서쪽을 바라보던 주사위면은 위를 바라보게 될 것이다. 이와 같이 주사위 면의 값들을 dice에 바꿔서 입력한다. 이 과정을 동,서,남,북에 나눠서 처리하고 그때마다 주사위 윗면의 값을 프린트해주면 된다. Full CodeFull Code","link":"/2019/12/27/%EC%A3%BC%EC%82%AC%EC%9C%84%EA%B5%B4%EB%A6%AC%EA%B8%B0-14499%EB%B2%88/"},{"title":"Centauri","text":"[Python] 백준1011번 풀이Fly me to the Alpha Centauri1.거리에 따른 이동 규칙을 찾는 문제였다. 마지막 거리1을 제외한 나머지 거리를 역으로 탐색하는 방법을 생각했지만 규칙성을 찾아서 해결하는 문제에 옳지 못한 방법이었다.&nbsp;&nbsp;&nbsp;타 게시판에서 힌트를 찾을 수 있었는데, 일정 거리를 지속적으로 늘려가다가 결국 마지막 1광년을 가기 위해 어느 시점부터 다시 지속적으로 움직이는 거리를 줄여야 한다는것이다. 2.그렇다면 어느 시점부터 다시 움직이는 거리를 줄이는 것일까?&nbsp;&nbsp;&nbsp;이에 대한 해답은 총 이동거리에 따라서 어떻게 움직여야하는지 표를 그려 파악할 수 있었다. 거리 이동경로 움직인 횟수 1 1 1 2 1 1 2 3 1 1 1 3 4 1 2 1 3 5 1 2 1 1 4 6 1 2 2 1 4 7 1 2 2 1 1 5 8 1 2 2 2 1 5 9 1 2 3 2 1 5 10 1 2 3 2 1 1 6 11 1 2 3 2 2 1 6 12 1 2 3 3 2 1 6 13 1 2 3 3 2 1 1 7 14 1 2 3 3 2 2 1 7 15 1 2 3 3 3 2 1 7 16 1 2 3 4 3 2 1 7 17 1 2 3 4 3 2 1 1 8 18 1 2 3 4 3 2 2 1 8 19 1 2 3 4 3 3 2 1 8 20 1 2 3 4 3 3 2 1 8 21 1 2 3 4 4 3 2 1 1 9 3.위의 표를 살펴보면 제곱수가 되는 K(볼드체가 표시되어 있는 2,3,4….) 를 기준으로 움직인 회수가 바뀌는것을 확인할 수 있다.&nbsp;&nbsp;&nbsp;다시말해, 우리가 움직여야하는 거리가 주어졌을 때 가장 가까운 제곱수로 나타낼 수 있는 값 K를 찾아야한다. 12345x, y = map(int, input().split())stand = 0if math.sqrt(y-x) - math.floor(math.sqrt(y-x)) &lt; 0.5: stand = math.floor(math.sqrt(y-x))else: stand = math.ceil(math.sqrt(y-x)) 총 움직여야하는 거리 y-x 에 대해&nbsp;&nbsp;&nbsp;sqrt값과 sqrt의 floor값 차이를 구해 이 값이 0.5 보다 작다면 기준이 되는 K값(위의 코드에서는 stand값)은 sqrt의 floor값이라고 할 수 있다.반대로, 0.5보다 크다면 K값은 sqrt의 ceil값이 될 것이다. 4.기준이 되는 값 K를 구했다면 K와 움직인 횟수와의 관계를 살펴봐야 한다.&nbsp;&nbsp;&nbsp;우리가 움직인 거리와 K의 제곱값을 비교하면 알 수 있다.&nbsp;&nbsp;&nbsp;만약, y-x가 K의 제곱보다 크다면 움직인 횟수는 K2이며&nbsp;&nbsp;&nbsp;y-x가 k의 제곱보다 작거나 같다면 움직인 횟수는 k2-1의 규칙을 따르는 것을 확인할 수 있다. 1234if y-x &gt; stand**2: print(stand*2)elif y-x &lt;= stand**2: print(stand*2-1) Full codeFull code","link":"/2019/12/30/Fly%20me%20to%20the%20Alpha%20Centauri/"},{"title":"부녀회장이될테야_2775번","text":"[Python] 백준 2775번 풀이부녀회장이 될테야1.처음 문제를 일고 떠오른것은 점화식 문제였다.&nbsp;&nbsp;&nbsp;점화식을 만들기 위해 몇층을 예로들어 직접 작성해보았다. 0층 : 1 2 3 4 5 6 7 8…1층 : 1 3 6 10 15 21 28…2층 : 1 4 10 20 25 56…3층 : 1 5 15 35 70…4층 : 1 6 21 56 몇개의 예를 들어 적어놓고 보니 계차수열의 형태를 나타낸다고 생각했다.하지만 층수가 높아질수록 계차수열에 계차수열이 더해지는 형태로 나타났고 이를 점화식으로 나타내는것은 무리가 따랐다.따라서, 문제에서 요구하는 층수와 호실수가 많지 않았으므로 전체에 대한 계산 결과를 저장하기로 결정했다. 123456789li = [[0]*14 for i in range(15)]for i in range(1,15): li[0][i-1] = i li[i][0] = 1for i in range(1,15): for j in range(1,14): li[i][j] = li[i-1][j] + li[i][j-1] 0층을 포함한 총 15층의 데이터를 저장하고 테스트 케이스로 입력받은 내용을 나타내는것으로 마무리했다. Full CodeFull Code","link":"/2020/01/01/%EB%B6%80%EB%85%80%ED%9A%8C%EC%9E%A5%EC%9D%B4%EB%90%A0%ED%85%8C%EC%95%BC-2775%EB%B2%88/"},{"title":"hexo블로그_댓글창만들기_icarus테마","text":"icarus테마 hexo블로그에 disqus 댓글창을 만들어보자icarus테마 블로그에 disqus댓글창을 만들고자 5시간의 삽질을 기록하는 이야기이다.1.disqus사이트에 접속해 아이디를 만들어아합니다. 2.홈 화면에서 get started를 누른다. 3.”I want to install Disqus on My site”를 누릅니다. 4.website이름을 만들고자하는 이름으로 입력하고 카테고리 언어를 설정한 후 create site를 클릭합니다. 5.여러 유료모델이 있지만 트래픽이 높지 않은 개인 블로그이므로(높을수도 있지만?!) Basic 모델아래에 Subscribe Now를 눌러줍니다. 6.어떤 플랫폼을 사용하는지 물어보지만 우리는 github.io를 사용하기때문에 제일 아래쪽의 I dont’ see my platform listed….을 눌러줍니다. 7.Universal Code install instructions창이 뜹니다. 8.해당 창에서 제일 위의 settings을 눌러줍니다. 9.새로 열리는 창의 두번째칸에 Shortname이 있습니다. Your website shortname is XXXXX라고 나옵니다. shortname을 기억하시면됩니다. 이제 github.io블로그를 꾸미는 터미널로 들어갑니다!테마마다 설정하는 법이 모두 다르기때문에 icarus테마를 기준으로 설명하겠습니다.icarus테마의 icarus테마 댓글창 설정법에 들어가면 _config파일만 수정해 적용하도록 나와있습니다. 1234comment: # Name of the comment plugin type: disqus shortname: &lt;9번에서 기억한 shortname&gt; 위와 같이 _config파일을 수정하고 적용을 시키고 테스트를 하기위해 서버를 실행시켰지만 터미널에서는 comment.shortname을 찾을 수 없다는 에러메시지였습니다.여기서부터 장장 5시간의 삽질이 시작됐습니다.저의 에디터에서는 저렇게 수정한것처럼 보였습니다…하지만 다른 커뮤니티에 문의하기 위해 comment 아래 부분을 복사해서 메모장에 붙여넣기 해보니 실제로 입력되어있던 내용은 1234comment: # Name of the comment plugin type: disqus shortname: &lt;shortname&gt; 였습니다. OMG…comment.shortname을 찾을 수 없다는 에러메시지가 나오는게 당연한 상황이었습니다저걸 찾기까지 무려 5시간이 걸리다니… 에디터에서는 바르게 “보이길래” 의심도 못했습니다.(역시 갓모장…)결국 footer수정… disqus.ejs파일 수정…등등 삽질을 끝낼 수 있었습니다. 저와같은 오류가 뜬다면 삽질을 막기위해 _config 문서를 수정하시고 메모장에 복사 붙여넣기를 해보세요!결론적으로 _config.yml 파일의 comment 내용을 다음과 같이 수정하시면 올바르게 적용됩니다! 1234comment: # Name of the comment plugin type: disqus shortname: &lt;9번에서 기억한 shortname&gt; disqus파일은 수정하지 않으셔도되고 위와같이 수정한 후 1hexo server -p &lt;포트번호&gt; ## 로컬에서 확인하기 로컬에서 확인한 후 12hexo generatehexo deploy 로 배포하시면 됩니다.","link":"/2020/01/03/hexo%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%8C%93%EA%B8%80%EC%B0%BD%EB%A7%8C%EB%93%A4%EA%B8%B0-icarus%ED%85%8C%EB%A7%88/"},{"title":"택시기하학_3053번","text":"[Python] 백준 3053번 풀이택시 기하학1.택시 기하학에서 원이 어떻게 정의되는지 이해하면 매우 간단한 문제이다.&nbsp;&nbsp;&nbsp; 아래의 그림을 통해 택시 기하학에서의 원을 살펴볼 수 있다. 직교 좌표계에서 같은 거리에 있는 점들의 집합을 원이라고 정의하므로 위와같이 나타낼 수 있다. 따라서 빨간 점들을 살펴보면 정사각형을 이루는것을 알 수 있고 정사각형의 넓이는 반지름 r이 주어졌을때 다음과 같이 구할 수 있다. 1k = 2*(r**2) ## 피타고라스 정리에 의해 c^2 = a^2 + b^2 = a^2 + a^2 = 2*a^2 Full CodeFull Code","link":"/2020/01/03/%ED%83%9D%EC%8B%9C%EA%B8%B0%ED%95%98%ED%95%99-3053%EB%B2%88/"},{"title":"블랙잭_2798번","text":"[Python] 백준 2798번 풀이블랙잭1.모든 조합의 경우의 수를 따지는 문제이다.파이썬에서는 itertools의 combinations를 이용해 조합을 따질 수 있다. itertools.combinations에서 확인할 수 있다. 2.combinations는 combinations object를 리턴하는데 이를 for루프에 돌려 하나의 조합을 확인하게되면 튜플 을 리턴한다.예를들어, 1234li = [3,4,5]for i in itertools.combinations(li,2): print(i)## &gt;&gt; (3,4) , (3,5) , (4,5) 를 출력한다. 3.따라서 입력받은 N개의 숫자 리스트로부터 모든 조합을 따지면서 그 값이 상한값을 넘지않는 경우 새로운 변수에 입력해주면 된다. 1234567com_li = 0for i in itertools.combinations(li,3): s = sum(i) if s &gt; com_li and s &lt;= m: com_li = s else: pass Full CodeFull Code","link":"/2020/01/03/%EB%B8%94%EB%9E%99%EC%9E%AD-2798%EB%B2%88/"},{"title":"Golang_정리하기-1","text":"[Go tutorial] Go 정리하기 - 1Go-tour 참조 익스포트 Go 에서는 첫 문자가 대문자로 시작하면 특정 패키지를 사용하는 곳에서 접근할 수 있는 exported name이 됨 함수 Go 는 코드를 왼쪽부터 자연스럽게 읽기 위해 매개변수 타입은 변수명 뒤에 명시. 두 개 이상의 매개변수가 같은 타입일 때, 같은 타입을 취하는 마지막 매개변수에만 타입을 지정할 수 있음. 12345x int, y int#를 아래와 같이도 사용 가능x, y int 하나의 함수는 여러 개의 결과를 반환할 수 있음. 123func swap(x, y string) (string, string) { return y, x} 변수 var 을 통해 변수를 선언. 변수 선언과 함꼐 초기화 가능, 초기화를 하는 경우 타입 생략 가능. 이 경우, 초기화하고자 하는 값에 따라 타입이 결정됨. 1var a, b, c int = 1, 2, 3 함수 내에서 := 을 사용하면 var와 명시적인 타입을 생략할 수 있음. 상수 const 키워드와 함께 변수처럼 선언. 상수는 문자, 문자열, boolean, 숫자 타입 중의 하나가 될 수 있음 숫자형 상수는 정밀한 값을 표현할 수 있음. Go-tour 사이트에서 제공하는 예제를 이해하기 위해서는 Go의 &lt;&lt; 와 &gt;&gt; 연산자의 이해가 필요하다. &lt;&lt;, &gt;&gt; 연산자에 대해 &lt;&lt; 와 &gt;&gt; 연산자는 비트 이동 연산자로 Left shift, Right shift 라고 함. Left shift 는 현재 값의 비트를 주어진 값만큼 왼쪽으로 Right shift는 현재 값의 비트를 주어진 값만큼 오른쪽으로 옮깁니다.1234567891011const (a = 1b = a &lt;&lt; 1)func main() { fmt.Println(a) ### 1 출력 fmt.Printf(\"%08b\\n\", a) ### 00000001 출력 fmt.Println(b) ### 2 출력 fmt.Printf(\"%08b\", b) ### 00000010 출력} 반복문 for Go 에는 반복문으로 for 하나만 존재. 조건문만 표현해서 루프를 표현 가능. 1234567func main() { sum := 1 for sum &lt; 1000 { sum += sum } fmt.Println(sum)} 위와 같이 표현하면 while을 사용하듯 for을 사용할 수 있다. 조건문을 생략하는것으로 무한 루프를 만들 수 있다. 1234func main() { for { }} 조건문 if 반복문과 마찬가지로 실행문을 위한 { } 만 필요. for 처럼 조건문 앞에 문장을 실행할 수 있음. 123456func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v &lt; lim { return v } return lim} 위의 예를 보면, v &lt; lim 을 통한 조건문 앞에 v := math.Pow(x,n) 을 실행했다. 이렇게 선언된 변수(위에서는 v)는 if 안쪽 범위에서만(else 블럭 안에서도 가능) 사용할 수 있다. 연습 : 루프와 함수 &gt;&gt;&gt; solution","link":"/2020/01/06/Golang-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-1/"},{"title":"Golang_정리하기_2","text":"[Go tutorial] Go 정리하기 - 2Go-tour 참조구름edu 참조 구조체(Structs) structs는 데이터들의 조합 type선언으로 이름을 지정할 수 있음 “객체이름 := 구조체이름{저장할값}”으로 입력해 선언과 동시에 초기화할 수 있다. 구조체에 속한 필드(데이터)는 dot(.)으로 접근 1234567891011121314151617181920212223242526type person struct { name string age int contact string}func main() { var p1 = person{} fmt.Println(p1) p1.name = \"kim\" p1.age = 25 p1.contact = \"01000000000\" fmt.Println(p1) p2 := person{\"nam\", 31, \"01022220000\"} // 필드 이름을 생력할 시 순서대로 저장함 fmt.Println(p2) p3 := person{contact: \"01011110000\", name: \"park\", age: 23} // 필드 이름을 명시할 시 순서와 상관 없이 저장할 수 있음 fmt.Println(p3) p3.name = \"ryu\" //필드에 저장된 값을 수정할 수 있음 fmt.Println(p3) fmt.Println(p3.contact) //필드 값의 개별 접근도 가능함} 포인터 포인터 연산은 불가능 포인터를 이용한 간접 접근은 실제 구조체에도 영향을 끼침 “&amp;” 을 매개변수 앞에 붙여 pass by reference 를 통해 값이 저장된 주소에 직접 접근할 수 있음. 구조체 포인터를 생성하는 방법은 두 가지가 있다. ‘new(구조체이름)’ 을 사용하여 객체를 생성 구조체 이름 앞에 &amp; 붙이기 12345678910111213141516171819type Person struct { Name string}func main() { c := new(Person) // returns pointer c.Name = \"Catherine\" fmt.Println(c.Name) // prints: Catherine d := *c d.Name = \"Daniel\" fmt.Println(d.Name) // prints: Daniel i := &amp;d i.Name = \"Ines\" fmt.Println(c.Name) // prints: Catherine fmt.Println(d.Name) // prints: Ines fmt.Println(i.Name) // prints: Ines} 슬라이스(slice) 슬라이스는 참조 타입이다. 따라서, 슬라이스를 복사한다는 것은 같은 주소를 참조한다는 것이다. 복사한 슬라이스의 값을 바꾸면 참조하는 슬라이스의 해당 값도 바뀌게 된다. 슬라이스 선언 var a []int = []int{1,2,3,4} 와 같이 선언과 함께 초기화 make() 함수를 이용. make(슬라이스 타입, 슬라이스 길이, 슬라이스 용량) ex) s:=make([]int,3,3) append() 함수를 통해 슬라이스에 데이터를 추가할 수 있다. 슬라이스에 슬라이스를 추가하기 위해서는 슬라이스 뒤에 “…”을 입력 12345678910func main() { sliceA := []int{1, 2, 3} sliceB := []int{4, 5, 6} sliceA = append(sliceA, sliceB...) //sliceA = append(sliceA, 4, 5, 6) fmt.Println(sliceA) fmt.Println(sliceB)} copy(붙여넣을 슬라이스, 복사할 슬라이스) 를 통해 한 슬라이스를 다른 슬라이스로 복사할 수 있다. 12345678910111213141516func main() { c := make([]int, 0, 3) //용량이 3이고 길이가0인 정수형 슬라이스 선언 c = append(c, 1, 2, 3, 4, 5, 6, 7) fmt.Println(len(c), cap(c)) l := c[1:3] //인덱스 1요소부터 2요소까지 복사 fmt.Println(l) l = c[2:] //인덱스 2요소부터 끝까지 복사 fmt.Println(l) l[0] = 6 fmt.Println(c) //슬라이스 l의 값을 바꿨는데 c의 값도 바뀜//값을 복사해온 것이 아니라 기존 슬라이스 주솟값을 참조} 위의 예제를 실행해보면 slice c의 값도 l 에 의해 바뀌는것을 확인할 수 있다. 왜냐하면, 슬라이스는 배열과 다르게 슬라이스 자체가 참조하고 있는 주소값을 같이 참조하기 때문이다. 슬라이스 순회(iterates) 슬라이스는 for 반복문에서 range를 통해 순회할 수 있다. 이때, index와 value를 순회하며 필요치 않은 값은 “_” 를 이용해 무시할 수 있다. 연습 : 슬라이스 - 문제 연습 : 슬라이스 - solution","link":"/2020/01/07/Golang-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-2/"},{"title":"Golang_정리하기_3","text":"[Go tutorial] Go 정리하기 - 3Go-tour 참조구름edu 참조 맵(map) 키와 value의 조합을 나타내기 위한것으로 파이썬의 딕셔너리를 생각하자. var 맵이름 map[key자료형]value자료형 으로 선언 var a map[int]string :: key가 int이고 value가 string인 맵 a 선언만 하고 초기화하지 않는다면 Nil map 이다. 데이터 추가 or 갱신 :: 맵이름[key] = value 를 이용 데이터 삭제 :: delete(맵이름,key) 를 이용 123456789101112131415161718192021func main() { //지역번호와 지역 저장 var m = make(map[string]string) m[\"02\"] = \"서울특별시\" m[\"031\"] = \"경기도\" m[\"032\"] = \"충청남도\" m[\"053\"] = \"대구광역시\" fmt.Println(m) //동일한 key값으로 value값을 저장하면 갱신이 된다 m[\"032\"] = \"인천\" fmt.Println(m) //m에 있는 \"031\"key의 value와 함께 삭제 delete(m, \"031\") fmt.Println(m)} key체크, value 확인 “맵이름[key]” 는 value와 키가 존재하는지 여부를 반환한다. 존재하지 않는 키값이라면 자료형에따라 0 혹은 “” 를 반환 해당 키가 존재하는지 여부에 따라 true/false 반환 12345678910111213141516func main() { m := make(map[string]int) m[\"Answer\"] = 42 fmt.Println(\"The value:\", m[\"Answer\"]) ## print : The value: 42 m[\"Answer\"] = 48 fmt.Println(\"The value:\", m[\"Answer\"]) ## print : The value: 48 delete(m, \"Answer\") fmt.Println(\"The value:\", m[\"Answer\"]) ## print : The value: 0 v, ok := m[\"Answer\"] fmt.Println(\"The value:\", v, \"Present?\", ok) ## print : The value: 0 Present? false} 연습 : 맵 - 문제 연습 : 맵 - solution 함수 클로져 클로져는 함수 안에서 익명 함수를 정의해 바깥쪽 함수에서 선언한 변수에도 접근할 수 있는 함수를 뜻한다. 1234567891011121314151617func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum }}func main() { pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ { fmt.Println( pos(i), neg(-2*i), ) }} 위의 예에서 adder() 함수는 지역 변수 sum 을 초기화하고 입력받는 x를 더해주는 익명 함수를 반환합니다. for문에서 함수가 실행될때마다 지역 변수가 초기화되지않고 더해주는 익명함수만을 통해 값이 지속적으로 증가/감소 하는것을 확인할 수 있습니다. 연습 : 피보나치 클로져 - 문제 연습 : 피보나치 클로져 - solution","link":"/2020/01/08/Golang-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-3/"},{"title":"분해합_2231번","text":"[Python, Go] 백준 2231번 풀이분해합 자연수 N의 생성자를 찾기 위해 1부터 N이전까지의 수를 모두 탐색한다. N이 1일때는 생성자가 존재하지 않으므로 0을 출력한다. i 를 키워나가면서 가장 작은 생성자를 찾으면 멈추고, N-1까지 탐색했을 때 결과값이 존재하지 않다면 0을 출력한다. i 의 각 자리수를 sum에 더해줄때, 각 자리수를 for문으로 돌려서 더해주었음. —&gt; 10으로 나누고 나머지를 사용하는 방법도있다. Python 풀이 1234567891011121314n = int(input())if n==1: print(0)for i in range(1,n): sum = i for j in str(i): sum += int(j) if sum == n: print(i) break elif i == n-1 : print(0) Go 풀이 Python과 같은 방법을 사용했는데 Go에서는 int를 스트링으로 바꿔주기 위해 “strconv”를 사용하였다. strconv.Itoa를 통해 int를 string으로 변환 strconv.ParseInt를 통해 string을 int로 바꿔주었다. 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\" \"strconv\")func main() { var n int fmt.Scanf(\"%d\", &amp;n) if n == 1 { fmt.Printf(\"%d\", 0) } for i := 1; i &lt; n; i++ { sum := i for _, j := range strconv.Itoa(sum) { k, _ := strconv.ParseInt(string(j), 10, 8) sum += int(k) } if sum == n { fmt.Printf(\"%d\", i) break } else if i == n-1 { fmt.Printf(\"%d\", 0) } }} Full CodeFull Code - Python Full Code - Go","link":"/2020/01/08/%EB%B6%84%ED%95%B4%ED%95%A9-2231%EB%B2%88/"},{"title":"Golang_정리하기_4","text":"[Go tutorial] Go 정리하기 - 4Go-tour 참조구름edu 참조 스위치 (switch) case의 라벨과 일치하는경우를 찾아 실행 어느것에도 맞지않다면 default문으로 실행 가능 break를 따로 입력하지 않아도 해당되는 case문만 실행된다. 스위치의 각 조건은 위에서 아래로 평가한다. 참인 case를 찾으면 평가를 마침. switch 전달 인자 태그 표현식 전달되는 인자 없이 case에 표현식 사용 가능 1234567891011121314151617func main() { var a, b int fmt.Print(\"정수 a와 b를 입력하시오:\") fmt.Scanln(&amp;a, &amp;b) switch { case a &gt; b: fmt.Println(\"a가 b보다 큽니다.\") case a &lt; b: fmt.Println(\"a가 b보다 작습니다.\") case a == b: fmt.Println(\"a와 b가 같습니다.\") default: fmt.Println(\"모르겠어요.\") }} 메소드와 인터페이스 메소드란 특정 속성들(구조체)을 이용해 기능을 수행하기 위해 만들어진 함수이다. 선언 “func (매개변수이름 구조체이름) 메소드이름() 반환형 {}” 형식으로 선언 매개변수 이름은 메소드 내에서 매개변수처럼 사용 123456789101112type Vertex struct { X, Y float64}func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y)}func main() { v := &amp;Vertex{3, 4} fmt.Println(v.Abs()) ### print : 5} 위의 예에서는 메소드에 구조체를 붙였다. 뿐만 아니라 메소드에는 아무 타입이나 붙일 수 있다. 12345678910111213type MyFloats float64func (f MyFloats) Abs() float64 { if f &lt; 0 { return float64(-f) } return float64(f)}func main() { k := MyFloats(-math.Sqrt2) fmt.Println(k.Abs()) ### print : 1.4142135623730951} 위의 예에서는 float타입을 메소드에 붙였다. 인터페이스 구조체가 변수를 묶어놓은 것이라면, 인터페이스는 메소드를 모아놓은 것이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( \"fmt\" \"math\")type geometry interface { area() float64 perimeter() float64 }type Rect struct { width, height float64}type Circle struct { radius float64}func (r Rect) area() float64 { return r.width * r.height}func (c Circle) area() float64 { return math.Pi * c.radius * c.radius}func (r Rect) perimeter() float64 { return 2 * (r.width + r.height)}func (c Circle) perimeter() float64 { .Pi * c.radius}func main() { r1 := Rect{10, 20} c1 := Circle{10} r2 := Rect{12, 14} c2 := Circle{5} printMeasure(r1, c1, r2, c2)}func printMeasure(m ...geometry) { for _, val := range m { fmt.Println(val) fmt.Println(val.area()) fmt.Println(val.perimeter()) }} 위의 예를 보면 인터페이스 안에 메소드가 들어가있다. 또한, 같은 이름의 메소드가 두개씩 있다. 이름이 동일하게 선언되어도 메소드가 전달받는 구조체가 다르기 때문에 괜찮은것이다. 메인함수에서 구조체를 초기화하고 for문을 통해 각 구조체를 전달받은 메소드에 대해 결과값을 출력하고 있다. 빈 인터페이스 인터페이스는 어떠한 타입도 담을 수 있는 dynamic type 이다. 인터페이스는 매개변수로 사용할 수 있다. 인터페이스는 내용을 따로 선언하지 않아도 형으로 사용할 수 있다. 하나의 변수를 형이 다른 형태로 저장해 출력한다고 생각한다면, 매개변수형에 따른 2개 이상의 함수를 만들어야한다. 하지만 빈 인터페이스를 사용한다면, 어떤 형도 담을 수 있기 때문에 편하게 사용이 가능하게된다. 1234567891011121314151617package mainimport \"fmt\"func printVal(i interface{}) { fmt.Println(i)}func main() { var x interface{} //빈 인터페이스 선언 x = 1 printVal(x) x = \"test\" printVal(x)} 위의 예에서 x의 값에따라 다르게 형을 선언하지 않고 출력하는것을 확인할 수 있다.","link":"/2020/01/09/Golang-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-4/"},{"title":"스택_10828번","text":"[Python, Go] 백준 10828번 풀이스택 주어지는 명령에 따라 스택을 처리하는 문제이다. 파이썬은 큐나 스택을 지원하는 라이브러리가 있지만 사용하지 않고 리스트를 통해 구현했으며, Go는 슬라이스를 통해 구현했다. 스택을 초기화할 필요가 있는 문제가 아니었으므로 하나의 파이썬의 경우 하나의 for문안에서 처리하고 Go는 각각의 명령에 따른 함수를 만들어 사용했다. Python 풀이 1234567891011121314151617181920212223242526272829303132333435import sysn = int(sys.stdin.readline())stack = []# n = int(input())for i in range(n): order = sys.stdin.readline().rstrip() # print(order) if len(order.split()) == 2: stack.insert(0,int(order.split()[1])) else: if order == \"pop\": if stack == []: print(-1) else: print(stack[0]) stack.pop(0) elif order == \"size\": print(len(stack)) elif order == \"empty\": if stack == []: print(1) else: print(0) # top else: if not stack == []: print(stack[0]) else: print(-1) Go를 통해 슬라이스를 다룰때 파이썬의 pop과 같은 내장함수가 없다. 따라서, 슬라이스에서 하나를 제거할 때 슬라이스의 길이가 1인경우와 1이 아닌경우를 나눠서 생각했다. 슬라이스의 길이가 1인경우, 남아있는 하나를 제거하고 empty slice를 만들기 위해 nil 처리 슬라이스의 길이가 1이 아닌 경우, 슬라이스의 가장 끝의 하나를 제거하면 되므로 슬라이스의 길이 L 을 구하고 L-1 까지의 슬라이스만을 가져간다. Go 풀이 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package mainimport ( \"bufio\" \"fmt\" \"os\" \"strconv\" \"strings\")var s []intfunc s_push(x int) { s = append(s, x)}func s_pop() { if s == nil { fmt.Printf(\"%d\\n\", -1) } else if len(s) == 1 { top := s[0] fmt.Printf(\"%d\\n\", top) s = nil } else { l := len(s) top := s[l-1] fmt.Printf(\"%d\\n\", top) s = s[:l-1] }}func s_size() { l := len(s) fmt.Printf(\"%d\\n\", l)}func s_empty() { if s == nil { fmt.Printf(\"%d\\n\", 1) } else { fmt.Printf(\"%d\\n\", 0) }}func s_top() { if s == nil { fmt.Printf(\"%d\\n\", -1) } else { l := len(s) top := s[l-1] fmt.Printf(\"%d\\n\", top) }}func main() { var n int inputReader := bufio.NewReader(os.Stdin) fmt.Scanf(\"%d\", &amp;n) for i := 0; i &lt; n+1; i++ { input, _ := inputReader.ReadString('\\n') order := strings.Split(input, \" \") action := strings.TrimSpace(order[0]) if len(order) == 2 { n := strings.TrimSpace(order[1]) num, _ := strconv.Atoi(n) s_push(num) } else { switch action { case \"pop\": s_pop() case \"size\": s_size() case \"empty\": s_empty() case \"top\": s_top() } } }} Full CodeFull Code - Python Full Code - Go","link":"/2020/01/15/%EC%8A%A4%ED%83%9D-10828%EB%B2%88/"},{"title":"for문에서_string_사용하기","text":"[Go] string(문자열)을 for문으로 출력, 이용하기 Go로 문제를 풀 때, 문자열을 for문으로 돌려야 하는 경우가 자주 발생했다. 파이썬같은 경우, 문자열을 다음과 같이 입력하면 문자열 그대로 출력된다. 12for i in \"CAT\": print(i) #print : C A T Go도 문자열을 for문에 사용할 수는 있지만, 파이썬과 달리 Go는 인덱스와 포인터 값을 반환한다. 123456789101112131415package mainimport \"fmt\"func main() { str := \"CAT\" for _, r := range str { c := string(r) fmt.Println(c) } fmt.Println() for i, r := range str { fmt.Println(i, r, string(r)) }} 위의 코드를 실행시켜보면, 다음과 같이 출력된다.CAT 0 67 C1 65 A2 84 T 위와같이, Go에서는 for문에서 문자열이 아닌 포인터값(int)을 반환한다. 따라서 문자열을 이용하고 싶을 경우, 새로운 변수를 만들고 이에 string()함수를 통해 초기화 시켜주어야 한다. 위의 예처럼, 반환받은 r값을 새로운 변수 c := string(r) 로 초기화 시켜서 사용.","link":"/2020/01/15/for%EB%AC%B8%EC%97%90%EC%84%9C-string-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"영화감독_숌_1436번","text":"[Python, Go] 백준 1436번 풀이영화감독 숌 숫자 6이 연속해서 3번 나타나는 수를 구하는 문제이다. 666, 1666, … , 5666, 의 다음은 6660, 6661, … 이다 666 부터 시작해서 수를 1씩 늘려가면서 모두 확인한다. 해당 수를 string으로 바꾸고 for문을 통해 6이 나왔을때 그 다음의 수도 6인지 그리고 그 다음 숫자도 6인지 확인하는 check 변수를 사용했다. 만약 check가 3이되면 해당 숫자는 6이 연속해서 3번 들어갔으므로 count를 1 증가시키고 주어진 목표만큼 count가 증가하면 종료, 출력했다. 123456789101112131415161718192021n = int(input())name = 666count = 0while True: if count == n: print(name-1) break else: check = 0 for i in str(name): if i == \"6\": check += 1 if check == 3: count += 1 continue else: pass else: check = 0 name += 1 Go도 같은 방식의 풀이지만, string을 for문에 돌릴때 반환되는 값은 포인터 값이므로 string(x) 로 바꿔주는것만 주의 참조 string을 int로 바꿀때 strconv.ParseInt 를 사용했으나 strconv.Atoi를 사용해도됨 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"fmt\" \"strconv\")func main() { var n int count := 0 name := 666 fmt.Scanf(\"%d\", &amp;n) for { if count == n { fmt.Printf(\"%d\", name-1) break } else { check := 0 for _, k := range strconv.Itoa(name) { v, _ := strconv.ParseInt(string(k), 10, 8) if v == 6 { check += 1 switch check { case 3: count += 1 } } else { check = 0 } } } name += 1 }} check 값이 3인지 확인할때 if문을 사용해도 괜찮지만 switch문을 사용해보았다. Full CodeFull Code - Python Full Code - Go","link":"/2020/01/15/%EC%98%81%ED%99%94%EA%B0%90%EB%8F%85-%EC%88%8C-1436%EB%B2%88/"},{"title":"괄호_9012번","text":"[Python, Go] 백준 9012번 풀이괄호 괄호의 쌍이 맞게 이루어져있는지 찾아내는 문제이다. “(“괄호와 “)” 괄호의 개수를 세는것에서 끝나면 안된다. 스택에 “(“ 가 들어왔을때 저장하고 “)” 와 만나면 스택에서 하나를 제거하는 방법으로 쌍을 맞춰주었다. 가장 먼저 들어오는 문자열이 “)” 이라면 쌍이 맞을 수 없으므로 NO 를 리턴하며, 문자열 모두를 파악한 후 stack이 비어있다면 YES 그렇지 않다면 NO 이다 Python 풀이 1234567891011121314151617181920212223242526import sysn = int(sys.stdin.readline())def vps(li): stack = [] if li[0] == \")\": return \"NO\" else: for s in li: if s == \"(\": stack.append(s) elif s == \")\" and stack != []: stack.pop() else: return \"NO\" if stack == []: return \"YES\" else: return \"NO\"for i in range(n): order = list(sys.stdin.readline().rstrip()) print(vps(order)) Go 풀이 Go 를 사용할때는 파이썬의 pop과같은 내장함수가 없으므로 “)”를 만났을때 슬라이스의 길이가 1인 경우와 그렇지 않은 경우를 나눠서 판단했다. func vps(x string) string { var stack []string for idx, ch := range x { s := string(ch) if idx == 0 &amp;&amp; s == \")\" { return \"NO\" } else { if s == \"(\" { stack = append(stack, s) } else if s == \")\" &amp;&amp; stack != nil { length := len(stack) if length == 1 { stack = nil } else { stack = stack[:length-1] } } else { return \"NO\" } } } if stack == nil { return \"YES\" } else { return \"NO\" } } Full CodeFull Code - Python Full Code - Go","link":"/2020/01/16/%EA%B4%84%ED%98%B8-9012%EB%B2%88/"},{"title":"균형잡힌_세상_4949번","text":"[Python, Go] 백준 4949번 풀이균형잡힌 세상 괄호문제 의 연장이다. 소괄호뿐만 아니라 대괄호까지 포함해 문장에서 괄호가 올바르게 되어져있는지 확인해야한다. 괄호안에 있는 괄호의 짝도 맞아야 yes를 출력할 수 있다. 예를들어 ( [ ) ] 와 같은 경우 하나의 괄호 안에 올바른 짝의 괄호가 들어가지 못했으므로 no 를 출력해야 한다. 정규표현식을 사용해 따라가야될 괄호들을 뺀 문자들은 pass 시켜주는 방법을 사용했다. 이외에는 괄호문제와같이 스텍에 ( 와 [ 를 담아서 사용했다. 단 ) 와 ] 를 만났을 때, 스텍의 마지막 요소가 짝이되는 괄호인지를 판별해줘야 한다. Python 풀이 12345678910111213141516171819202122232425262728293031323334def vps(line): stack = [] if line[0] == \")\" or line[0] == \"]\": # print(\"1\") return \"no\" else: pass for s in line: if bool(com.match(s)) == True: pass elif s == \" \" or s == \".\": pass elif s == \"(\" or s == \"[\": stack.append(s) # print(stack) elif s == \")\" and stack != []: if stack[-1] == \"(\": stack.pop() else: # print(\"2\") return \"no\" elif s == \"]\" and stack != []: if stack[-1] == \"[\": stack.pop() else: # print(\"3\") return \"no\" else: # print(\"4\") return \"no\" if stack == []: return \"yes\" else: # print(\"5\") return \"no\" Go 풀이 123456789101112131415161718192021222324252627282930313233343536373839404142434445func vps(x string) string { var stack []string // fmt.Println(string(x[0])) // return x if string(x[0]) == \")\" || string(x[0]) == \"]\" { return \"no\" } for _, ch := range x { s := string(ch) match, _ := regexp.MatchString(\"[a-zA-Z]\", s) if match == true { } else if s == \" \" || s == \".\" { } else if s == \"(\" || s == \"[\" { stack = append(stack, s) } else if s == \")\" &amp;&amp; stack != nil { if stack[len(stack)-1] == \"(\" { if len(stack) == 1 { stack = nil } else { stack = stack[:len(stack)-1] } } else { return \"no\" } } else if s == \"]\" &amp;&amp; stack != nil { if stack[len(stack)-1] == \"[\" { if len(stack) == 1 { stack = nil } else { stack = stack[:len(stack)-1] } } else { return \"no\" } } else { return \"no\" } } if stack == nil { return \"yes\" } else { return \"no\" }} Go로 풀이할때, 조건이 많을때는 switch가 더 좋기때문에 switch를 사용했다면 더 좋았을것같다. Full CodeFull Code - Python Full Code - Go","link":"/2020/01/19/%EA%B7%A0%ED%98%95%EC%9E%A1%ED%9E%8C-%EC%84%B8%EC%83%81-4949%EB%B2%88/"},{"title":"시간복잡도_big-O","text":"시간 복잡도(big-O)코딩 인터뷰 완전 분석(저 : 게일 라크만 맥도웰) 참조 실행 시간을 나타내기 위해 사용되는 개념이 시간 복잡도이다. 변수 N을 통해 O(logN), O(NlogN),… 등과 같이 표현하기도 하지만 이외에도 다양한 변수가 포함될 수 있다. 예를 들어, 너비가 w이고 높이가 h인 울타리를 칠한다고 할 때 소요 시간은 O(wh)로 표현할 수 있고 p번 덧칠한다면 O(pwh)로 표현할 수 있다. 상수항과 지배적이지 않은 항은 무시하자. big-O는 단순히 증가하는 비율을 나타내는 개념으로 수행 시간에 지배적이지 않은 항은 무시할 수 있다. 두 개의 중첩되지 않은 루프로 이루어진 코드의 수행 시간을 O(2N) 과 같이 표현할 수도 있지만 이는 결국 O(N)과 같은 의미이다. 마찬가지로, O(N^2 + N)과 같은 수행 시간이 있을 때, N^2이 지배적인 항이므로(N에 비해 빠르게 증가하기 떄문) O(N^2 + N) 은 O(N^2) 이 된다. 즉, big-O 는 수행 시간이 어떻게 변화하는지를 표현해주는 도구이다. 덧셈? 곱셈?? 두 단계로 이루어진 알고리즘이 있을 경우, 수행 시간을 어떤 경우에는 더하고 혹은 곱해야 하는걸까? 1234567### 덧셈 수행 시간 : O(A+B)for (int a : arrA) { print(a);}for (int b : arrB) { print(b);} 위와 같이 A의 일을 모두 끝마친 후 B의 일을 시행하는 형태라면 A와 B의 수행 시간을 더해야 한다. 123456### 곱셈 수행 시간 : O(A*B)for (int a : arrA) { for (int b : arrB) { print(a + \",\" + b); }} 위와 같이 A의 일을 할 때마다 B의 일을 시행하는 형태라면 A와 B의 수행 시간을 곱해야 한다. log N 수행 시간 logN 수행 시간이 어떻게 나오는지 알기 위해 이진 탐색을 생각해보자. 이진 탐색은 N개의 정렬된 원소가 들어있는 배열에서 원소 x를 찾을 때, 배열의 중간값과 x의 값을 비교하여 배열의 부분을 재탐색하는 것이다. 예를 들어, 16개의 원소를 가진 배열을 생각해보자. N = 16 이진 탐색을 통해 각 단계별로 탐색해야 하는 원소의 개수는 다음과 같다. 12345N = 16 # 처음N = 8 # 나누기 2N = 4 # 나누기 2N = 2 # 나누기 2N = 1 # 나누기 2, 찾고자하는 원소 x를 찾았다. 즉, 총 수행 시간은 N을 절반씩 나누는 과정을 몇단계 거쳐서 1이 되는지에 따라서 결정된다. 위의 경우를 반대로 생각해보자. 1에서 16으로 증가하려면 1에서 2를 몇번 곱해야 할까? 12345N = 1 # 처음N = 2 # 곱하기 2N = 4 # 곱하기 2N = 8 # 곱하기 2N = 16 # 곱하기 2 다시 말해, 절반씩 나누는 과정(나누기2)을 1에서 2를 곱해가는 과정으로도 표현할 수 있다는 뜻이다. 이는, 2를 k번 곱해서 N이 된다고 말할 수 있으며 다음과 같은 수식으로 나타낼 수 있다. 12^k = N 위 수식을 만족하는 k는 무엇인가? k를 찾기 위해 양 변에 밑이 2인 로그를 취해주자. 1234### &lt;밑이 2인 로그입니다.&gt;---&gt; log(2^k) = logN---&gt; k * log2 = logN---&gt; k = logN (∵ log2 = 1) big-O 에서는 로그의 밑을 고려할 필요가 없다. 위에서 밑이 10인 로그를 취했다 할지라도 이는 상수항일 뿐이다. 시작할 때 말했듯이 big-O 에서 상수항은 무시할 수 있다. 재귀함수의 수행 시간 다음과 같은 재귀함수의 수행 시간은 어떻게 될까? 123456int f(int n) { if (n&lt;=1) { return 1; } return f(n-1) + f(n-1);} 함수 f가 두번 호출되는것을 보고 O(N^2)이라고 생각할 수 있지만 틀렸다. f(4) 일때 위와 같이 f(3)을 두번 호출하고 f(3)은 f(2)를 거쳐 f(1)까지 호출한다. 위와 같이 두 개의 자식 노트를 가진 경우 총 호출 횟수는 얼마인가? 호출 횟수를 표로 나타내보자. 깊이 노드의 개수 2^N 표현 0 1 20 1 2 21 2 4 22 3 8 23 4 16 24 따라서, 전체 노드의 개수는 20 + 21 + 22 + 23 + … + 2N = 2N+1 - 1 이다. 즉, 위와 같은 재귀 함수의 수행 시간은 O(2N)이 된다. 보통 다수의 호출로 이루어진 재귀 함수의 수행 시간은 O(분기깊이) 로 표현할 수 있다. 여기서 분기란 재귀 함수가 자신을 재호출 하는 횟수를 뜻한다.","link":"/2020/01/23/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-big-O/"},{"title":"탑_2493번","text":"[Python] 백준 2493번 풀이탑 순서대로 주어지는 탑의 높이를 기준으로 전파가 닿는곳을 구하기 혹은 닿지 않는지를 판단하는 스텍 문제이다. 입력되는 탑의 높이를 스텍에 담아두고 판별한다. 스텍에 특정 높이의 탑이 있을 때, 다음에 들어가는 탑의 높이가 더 높다면 스텍에서 top을 지우면 된다. 왜냐하면, 스텍의 top보다 높은 높이의 탑을 입력받았다면 그 이후에 입력받는 모든 탑들의 전파는 스텍 top에 있는 탑에는 절대 도달할 수 없기 때문이다. 만약 스텍에 판단할 수 있는 top이 없다면 스텍에 입력을 집어넣고 0 을 출력하면 된다. 스텍에 특정 높이의 탑이 있을 때, 다음에 들어가는 탑의 높이가 더 낮다면 스텍에 입력받은 탑의 높이를 top으로 입력하고 이전 top의 위치를 출력해준다. 왜냐하면, 이후에 입력받은 탑의 높이까지 판단해야 하기 때문에 출력과 동시에 스텍의 top으로 저장해준다. 주의할점은, 이렇게 전파가 가로막혀 위치를 출력했다면 while 루프를 벗어나서 다음에 입력받는 탑의 높이로 돌아가야 한다는 것이다. 전파가 가로막혔을 때, 해당 탑의 위치를 출력해야 하는 문제이므로 스텍안에 “(인덱스, 탑의 높이)” 를 갖는 튜플을 저장했다. python 풀이 1234567891011121314151617181920212223242526import sysn = int(sys.stdin.readline())tower = list(map(int, sys.stdin.readline().split()))stack = []for idx,i in enumerate(tower): # print(stack) while stack: if i &gt; stack[-1][1]: stack.pop() elif i &lt; stack[-1][1]: print(stack[-1][0], end=\" \") stack.append((idx+1,i)) break if not stack: stack.append((idx+1,i)) print(0, end=\" \") else: continue Full CodeFull Code - Python","link":"/2020/01/25/%ED%83%91-2493%EB%B2%88/"},{"title":"CtCI_Ch1_배열과_문자열","text":"Ch1. 배열과 문자열코딩 인터뷰 완전 분석(저 : 게일 라크만 맥도웰) 참조 해시테이블 해시테이블(파이썬의 dict)은 키와 값으로 대응되는 자료구조이다. 해시코드 충돌로 인해 최악의 수행 시간은 O(N)이지만, 일반적으로 탐색 시간은 O(1)이다. python dict time complexity에서 시간 복잡도를 확인할 수 있다. 리스트 가변 크기의 자료구조를 원할 때는 리스트(배열)을 사용하게 된다. 리스트는 O(1)의 접근 시간을 유지한다. 리스트의 크기를 두배로 늘리는 시간은 O(n)이지만, 자주 발생하는 일이 아니라서 상환 입력 시간은 O(1)이 된다. Go 를 생각해보자. 슬라이스에 아이템을 하나씩 append 하다가 처음에 정의한 슬라이스의 크기보다 더 들어가야 된다면 그때, 슬라이스의 크기가 두배 늘어나는 상황이다. 상환 입력 시간이 O(1)인 이유 크기가 N인 배열을 생각해보자. N개의 원소를 삽입하기 위해 얼마나 많은 원소를 복사해야 하는지 역으로 계산할 수 있다. 12345678마지막 배열 크기 증가 : n/2 개의 원소 복사이전 배열 크기 증가 : n/4 개의 원소 복사이전 배열 크기 증가 : n/8 개의 원소 복사...두 번쨰 배열 크기 증가 : 2 개의 원소 복사첫 번째 배열 크기 증가 : 1 개의 원소 복사 즉, N개의 원소를 삽입하기 위해 복사해야 하는 원소의 총 개수는 1+2+…N/8+N/4+N/2 이며 이는 N보다 작다. 따라서, O(N)이 소요되는 삽입 연산도 존재하기는 하지만 평균적으로 삽입 연산은 O(1)이 소요된다. Ch1. 연습문제 코드CtCI_Ch1_Python","link":"/2020/01/30/CtCI-Ch1-%EB%B0%B0%EC%97%B4%EA%B3%BC-%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"title":"CtCI_Ch3_스택과큐","text":"Ch3. 스택과 큐코딩 인터뷰 완전 분석(저 : 게일 라크만 맥도웰) 참조 스택 구현하기 스택은 데이터를 쌓아올리는 자료구조이다. 스택은 LIFO(Last-In-First-Out)에 따라 자료를 배열한다. 즉, 가장 최근에 스택에 추가한 항목이 가장 먼저 제거될 항목이 된다. 스택에는 다음과 같은 연산이 존재한다. pop(): 스택에서 가장 위에 있는 항목을 제거한다. push(item): item을 스택의 가장 위에 추가한다. peek(): 스택의 가장 위에 있는 항목을 반환한다. isEmpty(): 스택이 비어있을 때에 True를 반환한다. 파이썬을 통해 스택을 아래와 같이 구현할 수 있다. 12345678910111213141516171819202122232425262728class Stack(): def __init__(self): self.stack = [] def __len__(self): return len(self.stack) def isempty(self): if self.stack: return False else: return True def push(self, num): self.stack.append(num) def pop(self): if self.stack: return self.stack.pop() else: raise Exception(\"stack is empty\") def peek(self): if self.stack: return self.stack[-1] else: raise Exception(\"stack is empty\") 큐 구현하기 큐는 FIFO(First-In-First-Out)에 따라 자료를 배열한다. 즉, 큐에 저장되는 항목들은 추가되는 순서대로 제거된다. 큐에는 다음과 같은 연산이 존재한다. add(item): item을 리스트의 끝부분에 추가한다. remove(item): 리스트의 첫 번쨰 항목을 제거한다. peek(): 큐에서 가장 위에 있는 항목을 반환한다. isEmpty(): 큐가 비어있을 때 True를 반환한다. 파이썬을 통해 아래와 같이 큐를 구현할 수 있다. 123456789101112131415161718192021222324252627class Queue(): def __init__(self): self.queue = [] def push(self, num): self.queue.append(num) def pop(self): if self.queue: item = self.queue[0] self.queue = self.queue[1:] return item else: raise Exception(\"Queue is empty\") def peek(self): if self.queue: return self.queue[0] else: raise Exception(\"Queue is empty\") def isEmpty(self): if not self.queue: return True else: return False Ch3. 연습문제 코드CtCI_Ch3_Python","link":"/2020/02/04/CtCI-Ch3-%EC%8A%A4%ED%83%9D%EA%B3%BC%ED%81%90/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"baekjoon","slug":"baekjoon","link":"/tags/baekjoon/"},{"name":"github.io","slug":"github-io","link":"/tags/github-io/"},{"name":"블로그","slug":"블로그","link":"/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"CS","slug":"CS","link":"/tags/CS/"},{"name":"CtCI","slug":"CtCI","link":"/tags/CtCI/"}],"categories":[{"name":"baekjoon","slug":"baekjoon","link":"/categories/baekjoon/"},{"name":"python","slug":"baekjoon/python","link":"/categories/baekjoon/python/"},{"name":"github.io","slug":"github-io","link":"/categories/github-io/"},{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"tutorial","slug":"Go/tutorial","link":"/categories/Go/tutorial/"},{"name":"Go","slug":"baekjoon/Go","link":"/categories/baekjoon/Go/"},{"name":"About Go","slug":"Go/About-Go","link":"/categories/Go/About-Go/"},{"name":"CS basic","slug":"CS-basic","link":"/categories/CS-basic/"},{"name":"CtCI","slug":"CS-basic/CtCI","link":"/categories/CS-basic/CtCI/"}]}